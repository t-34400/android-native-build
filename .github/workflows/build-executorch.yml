name: build-executorch-android
on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build-arm64:
    runs-on: ubuntu-22.04
    env:
      ANDROID_ABI: arm64-v8a
      ANDROID_API: 26
      BUILD_TYPE: Release
      EXECUTORCH_VER: v0.7.0

    steps:
      - uses: actions/checkout@v4

      - name: Setup CMake
        uses: lukka/get-cmake@v3.30.3

      - name: Setup Android NDK r27b
        id: ndk
        uses: nttld/setup-ndk@v1
        with:
          ndk-version: r27b

      - name: Clone ExecuTorch ${{ env.EXECUTORCH_VER }}
        run: |
          git clone --branch "${EXECUTORCH_VER}" --depth 1 https://github.com/pytorch/executorch.git
          cd executorch
          git submodule update --init --recursive

      - name: Install Python deps
        working-directory: executorch
        run: python3 -m pip install -r requirements-dev.txt

      - name: Prepare
        working-directory: executorch
        run: bash ./install_executorch.sh --clean

      - name: Python deps for codegen/buck2
        working-directory: executorch
        run: python3 -m pip install -r requirements-dev.txt

      - name: Install PyTorch (CPU wheel for host-side tools)
        run: python3 -m pip install --index-url https://download.pytorch.org/whl/test/cpu torch

      - name: Upgrade pip build base
        run: python3 -m pip install -U "pip>=24" "setuptools>=70" "wheel>=0.43" "packaging>=24.2"

      - name: Install ExecuTorch (Python)
        run: python3 -m pip install "executorch>=0.7,<0.8"

      - name: Prepare PYTHONPATH and sitecustomize
        working-directory: executorch
        run: |
          : > sitecustomize.py
          echo "PYTHONPATH=$PWD" >> $GITHUB_ENV

      - name: Check codegen imports
        working-directory: executorch
        run: |
          python3 - <<'PY'
          import os
          print("PYTHONPATH =", os.environ.get("PYTHONPATH"))
          import executorch, executorch.codegen, torchgen
          print("imports OK")
          PY

      - name: Hard clean any host-built artifacts
        working-directory: executorch
        run: |
          git clean -fdx -e cmake-android-out

      - name: Configure (force Android aarch64 toolchain)
        working-directory: executorch
        env:
          ANDROID_NDK: ${{ steps.ndk.outputs.ndk-path }}
          ANDROID_ABI: arm64-v8a
          ANDROID_API: 26
          BUILD_TYPE: Release
        shell: bash
        run: |
          set -euo pipefail

          # Use NDK target-specific wrapper compilers
          HOST_BIN="linux-x86_64"
          case "$(uname -s)" in
            Darwin) HOST_BIN="darwin-x86_64" ;;
            MINGW*|MSYS*|CYGWIN*) HOST_BIN="windows-x86_64" ;;
          esac
          TOOLBIN="${ANDROID_NDK}/toolchains/llvm/prebuilt/${HOST_BIN}/bin"
          export CC="${TOOLBIN}/aarch64-linux-android${ANDROID_API}-clang"
          export CXX="${TOOLBIN}/aarch64-linux-android${ANDROID_API}-clang++"
          export AR="${TOOLBIN}/llvm-ar"
          export RANLIB="${TOOLBIN}/llvm-ranlib"
          export STRIP="${TOOLBIN}/llvm-strip"

          # Sanity: compilers must exist
          test -x "$CC" && test -x "$CXX" || { echo "ERROR: aarch64 wrappers not found"; exit 1; }

          rm -rf cmake-android-out
          cmake -S . -B cmake-android-out \
            -DCMAKE_SYSTEM_NAME=Android \
            -DCMAKE_TOOLCHAIN_FILE="${ANDROID_NDK}/build/cmake/android.toolchain.cmake" \
            -DCMAKE_ANDROID_NDK="${ANDROID_NDK}" \
            -DANDROID_ABI="${ANDROID_ABI}" \
            -DANDROID_PLATFORM=android-${ANDROID_API} \
            -DCMAKE_BUILD_TYPE="${BUILD_TYPE}" \
            -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
            -DCMAKE_C_COMPILER="$CC" \
            -DCMAKE_CXX_COMPILER="$CXX" \
            -DCMAKE_ASM_COMPILER="$CC" \
            -DCMAKE_TRY_COMPILE_TARGET_TYPE=STATIC_LIBRARY \
            -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
            -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
            -DTHREADS_PREFER_PTHREAD_FLAG=ON \
            -DEXECUTORCH_BUILD_EXECUTOR_RUNNER=OFF \
            -DEXECUTORCH_BUILD_XNNPACK=ON \
            -DEXECUTORCH_BUILD_EXTENSION_DATA_LOADER=ON \
            -DEXECUTORCH_BUILD_EXTENSION_MODULE=ON \
            -DEXECUTORCH_BUILD_EXTENSION_FLAT_TENSOR=ON \
            -DEXECUTORCH_BUILD_EXTENSION_TENSOR=ON

          # Print the compilers CMake actually recorded
          grep -E 'CMAKE_(C|CXX|ASM)_COMPILER(:|=)' cmake-android-out/CMakeCache.txt || true
                        
      - name: Prepare full c10
        working-directory: executorch
        shell: bash
        env:
          PYTORCH_REF: v2.4.0
        run: |
          set -euo pipefail
          mkdir -p jni/include
          rm -rf jni/include/c10
          tmp=$(mktemp -d)
          trap 'rm -rf "$tmp"' EXIT
          git init "$tmp/pt" >/dev/null
          git -C "$tmp/pt" remote add origin https://github.com/pytorch/pytorch.git
          git -C "$tmp/pt" sparse-checkout init --cone
          git -C "$tmp/pt" sparse-checkout set c10
          if git -C "$tmp/pt" fetch --depth 1 origin "$PYTORCH_REF" >/dev/null 2>&1; then
            git -C "$tmp/pt" checkout --force FETCH_HEAD >/dev/null 2>&1 || true
          else
            echo "WARN: PYTORCH_REF=${PYTORCH_REF} not found; falling back to main"
            git -C "$tmp/pt" fetch --depth 1 origin main >/dev/null
            git -C "$tmp/pt" checkout --force FETCH_HEAD >/dev/null 2>&1 || true
          fi
          rsync -a "$tmp/pt/c10/" "jni/include/c10/"
          NEEDS_GEN=0
          if grep -q '#include <c10/macros/cmake_macros.h>' jni/include/c10/macros/Macros.h 2>/dev/null; then
            NEEDS_GEN=1
          fi
          if [ "$NEEDS_GEN" -eq 1 ] && [ ! -f jni/include/c10/macros/cmake_macros.h ]; then
            if [ -f "$tmp/pt/c10/macros/cmake_macros.h.in" ]; then
              printf '%s\n' \
                'cmake_minimum_required(VERSION 3.13)' \
                'project(gen_c10_macros C)' \
                'configure_file("${SRC_IN}" "${DST}/cmake_macros.h" @ONLY)' \
                > "$tmp/CMakeLists.txt"
              cmake -S "$tmp" -B "$tmp/_b" \
                    -DSRC_IN="$tmp/pt/c10/macros/cmake_macros.h.in" \
                    -DDST="$tmp/_out" >/dev/null
              test -f "$tmp/_out/cmake_macros.h" || { echo "ERROR: Failed to generate c10/macros/cmake_macros.h."; exit 1; }
              mkdir -p jni/include/c10/macros
              cp -f "$tmp/_out/cmake_macros.h" jni/include/c10/macros/
              echo "Generated: jni/include/c10/macros/cmake_macros.h"
            else
              echo "WARN: cmake_macros.h.in not present at ${PYTORCH_REF}; Macros.h may be headeronly-based."
            fi
          fi
          test -f jni/include/c10/macros/Macros.h || { echo "ERROR: c10/macros/Macros.h missing."; exit 1; }
          if grep -q '#include <c10/macros/cmake_macros.h>' jni/include/c10/macros/Macros.h; then
            test -f jni/include/c10/macros/cmake_macros.h || { echo "ERROR: c10/macros/cmake_macros.h missing."; exit 1; }
          fi

      - name: Build
        working-directory: executorch
        run: cmake --build cmake-android-out -j

      - name: Verify artifacts are AArch64
        working-directory: executorch
        env:
          ANDROID_NDK: ${{ steps.ndk.outputs.ndk-path }}
        shell: bash
        run: |
          set -euo pipefail

          # Resolve tool paths
          HOST_BIN="linux-x86_64"
          case "$(uname -s)" in
            Darwin) HOST_BIN="darwin-x86_64" ;;
            MINGW*|MSYS*|CYGWIN*) HOST_BIN="windows-x86_64" ;;
          esac
          TOOLBIN="${ANDROID_NDK}/toolchains/llvm/prebuilt/${HOST_BIN}/bin"
          READOBJ="${TOOLBIN}/llvm-readobj"
          ARBIN="${TOOLBIN}/llvm-ar"
          command -v "$READOBJ" >/dev/null 2>&1 || READOBJ=llvm-readobj
          command -v "$ARBIN"   >/dev/null 2>&1 || ARBIN=llvm-ar

          # Collect libraries
          mapfile -d '' libs < <(find cmake-android-out -type f \( -name 'lib*.a' -o -name 'lib*.so' \) -print0)
          if [ "${#libs[@]}" -eq 0 ]; then
            echo "ERROR: No libraries found under cmake-android-out"
            exit 1
          fi

          bad=0
          for f in "${libs[@]}"; do
            # Check the library/so itself
            if ! "$READOBJ" --file-headers "$f" | grep -q 'Machine: AArch64'; then
              echo "ERROR: Non-AArch64 artifact: $f"
              bad=1
            fi

            # For static archives, also check member objects
            if [[ "$f" == *.a ]]; then
              tmp="$(mktemp -d)"
              pushd "$tmp" >/dev/null
              mapfile -t members < <("$ARBIN" t "$OLDPWD/$f" || true)
              for obj in "${members[@]}"; do
                [ -n "$obj" ] || continue
                "$ARBIN" x "$OLDPWD/$f" "$obj" >/dev/null 2>&1 || { echo "ERROR: Failed to extract $obj from $f"; bad=1; break; }
                if ! "$READOBJ" --file-headers "$obj" | grep -q 'Machine: AArch64'; then
                  echo "ERROR: Archive contains non-AArch64 object: $f -> $obj"
                  bad=1
                  break
                fi
              done
              popd >/dev/null
              rm -rf "$tmp"
            fi
          done

          if [ "$bad" -ne 0 ]; then
            exit 1
          fi

          echo "OK: All libraries (and archive members) are AArch64"

      - name: Package headers & libs (arm64 only)
        working-directory: executorch
        env:
          ABI: ${{ env.ANDROID_ABI }}
          ANDROID_NDK: ${{ steps.ndk.outputs.ndk-path }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p jni/include "libs/${ABI}"
          rsync -a --prune-empty-dirs --include '*/' --include '*.h' --include '*.hpp' --include '*.inc' --exclude '*' ./ jni/include/executorch/
          HOST_BIN="linux-x86_64"
          case "$(uname -s)" in
            Darwin) HOST_BIN="darwin-x86_64" ;;
            MINGW*|MSYS*|CYGWIN*) HOST_BIN="windows-x86_64" ;;
          esac
          TOOLBIN="${ANDROID_NDK}/toolchains/llvm/prebuilt/${HOST_BIN}/bin"
          READOBJ="${TOOLBIN}/llvm-readobj"; ARBIN="${TOOLBIN}/llvm-ar"
          command -v "$READOBJ" >/dev/null 2>&1 || READOBJ=llvm-readobj
          command -v "$ARBIN"   >/dev/null 2>&1 || ARBIN=llvm-ar

          copied=0
          while IFS= read -r -d '' lib; do
            base="$(basename "$lib")"; dir="$(dirname "$lib")"
            if [[ "$base" == *.so ]]; then
              "$READOBJ" --file-headers "$lib" | grep -q "Machine: AArch64" && { cp -f "$lib" "libs/${ABI}/"; copied=$((copied+1)); }
              continue
            fi
            ok=1; moved=0
            tmp_extract="$(mktemp -d)"; tmp_new="$(mktemp -d)"
            pushd "$dir" >/dev/null
            "$ARBIN" t "$base" > "$tmp_extract/list.txt" || ok=0
            [[ -s "$tmp_extract/list.txt" ]] || ok=0
            mkdir -p "$tmp_new/objs"
            if [[ "$ok" -eq 1 ]]; then
              while IFS= read -r obj; do
                "$ARBIN" x "$base" "$obj" >/dev/null 2>&1 || { ok=0; break; }
                [[ -f "$obj" ]] || { ok=0; break; }
                "$READOBJ" --file-headers "$obj" | grep -q "Machine: AArch64" || { ok=0; break; }
                mkdir -p "$tmp_new/objs/$(dirname "$obj")"
                mv -f "$obj" "$tmp_new/objs/$obj"
                moved=$((moved+1))
              done < "$tmp_extract/list.txt"
              sed 's|^|rm -f -- |' "$tmp_extract/list.txt" | bash || true
            fi
            popd >/dev/null
            if [[ "$ok" -eq 1 && "$moved" -gt 0 ]]; then
              pushd "$tmp_new/objs" >/dev/null
              "$ARBIN" crs "$tmp_new/$base" $(find . -type f -name '*.o' -printf '%P\n')
              popd >/dev/null
              cp -f "$tmp_new/$base" "libs/${ABI}/$base"; copied=$((copied+1))
            fi
            rm -rf "$tmp_extract" "$tmp_new"
          done < <(find cmake-android-out -type f \( -name 'lib*.a' -o -name 'lib*.so' \) -print0)

          if [[ $copied -eq 0 ]]; then
            echo "ERROR: No AArch64 libraries were packaged into libs/${ABI}." 1>&2; exit 1
          fi

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: executorch-android-${{ env.ANDROID_ABI }}
          path: |
            executorch/jni/include
            executorch/libs/${{ env.ANDROID_ABI }}
